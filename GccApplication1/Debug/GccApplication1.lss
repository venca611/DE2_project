
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b2  00800100  00000a18  00000aac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000a18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004f  008001b2  008001b2  00000b5e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b5e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000b90  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000180  00000000  00000000  00000bd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001c08  00000000  00000000  00000d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c77  00000000  00000000  00002958  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f3f  00000000  00000000  000035cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000474  00000000  00000000  00004510  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000700  00000000  00000000  00004984  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000127f  00000000  00000000  00005084  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c0  00000000  00000000  00006303  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 91 03 	jmp	0x722	; 0x722 <__vector_9>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 11 03 	jmp	0x622	; 0x622 <__vector_13>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 ed 02 	jmp	0x5da	; 0x5da <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 40 04 	jmp	0x880	; 0x880 <__vector_18>
  4c:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <__vector_19>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e8 e1       	ldi	r30, 0x18	; 24
  7c:	fa e0       	ldi	r31, 0x0A	; 10
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 3b       	cpi	r26, 0xB2	; 178
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	22 e0       	ldi	r18, 0x02	; 2
  8c:	a2 eb       	ldi	r26, 0xB2	; 178
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a1 30       	cpi	r26, 0x01	; 1
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 ca 02 	call	0x594	; 0x594 <main>
  9e:	0c 94 0a 05 	jmp	0xa14	; 0xa14 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <GPIO_read>:
/* GPIO_read */
uint8_t GPIO_read(volatile uint8_t *reg_name, uint8_t pin_num)
{
	// kdyz je dany bit na dane adrese 0
	// tak se vrati 0 jinak 1
	if(bit_is_clear(*reg_name, pin_num))
  a6:	fc 01       	movw	r30, r24
  a8:	80 81       	ld	r24, Z
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	02 c0       	rjmp	.+4      	; 0xb2 <GPIO_read+0xc>
  ae:	95 95       	asr	r25
  b0:	87 95       	ror	r24
  b2:	6a 95       	dec	r22
  b4:	e2 f7       	brpl	.-8      	; 0xae <GPIO_read+0x8>
		return 0;
	else
		return 1;
  b6:	81 70       	andi	r24, 0x01	; 1
  b8:	08 95       	ret

000000ba <toggle_e>:

    while ( (c = pgm_read_byte(progmem_s++)) )
    {
        lcd_putc(c);
    }
}/* lcd_puts_p */
  ba:	29 9a       	sbi	0x05, 1	; 5
  bc:	85 e0       	ldi	r24, 0x05	; 5
  be:	8a 95       	dec	r24
  c0:	f1 f7       	brne	.-4      	; 0xbe <toggle_e+0x4>
  c2:	00 00       	nop
  c4:	29 98       	cbi	0x05, 1	; 5
  c6:	08 95       	ret

000000c8 <lcd_write>:
  c8:	cf 93       	push	r28
  ca:	c8 2f       	mov	r28, r24
  cc:	66 23       	and	r22, r22
  ce:	11 f0       	breq	.+4      	; 0xd4 <lcd_write+0xc>
  d0:	28 9a       	sbi	0x05, 0	; 5
  d2:	01 c0       	rjmp	.+2      	; 0xd6 <lcd_write+0xe>
  d4:	28 98       	cbi	0x05, 0	; 5
  d6:	54 9a       	sbi	0x0a, 4	; 10
  d8:	55 9a       	sbi	0x0a, 5	; 10
  da:	56 9a       	sbi	0x0a, 6	; 10
  dc:	57 9a       	sbi	0x0a, 7	; 10
  de:	5f 98       	cbi	0x0b, 7	; 11
  e0:	5e 98       	cbi	0x0b, 6	; 11
  e2:	5d 98       	cbi	0x0b, 5	; 11
  e4:	5c 98       	cbi	0x0b, 4	; 11
  e6:	cc 23       	and	r28, r28
  e8:	0c f4       	brge	.+2      	; 0xec <lcd_write+0x24>
  ea:	5f 9a       	sbi	0x0b, 7	; 11
  ec:	c6 fd       	sbrc	r28, 6
  ee:	5e 9a       	sbi	0x0b, 6	; 11
  f0:	c5 fd       	sbrc	r28, 5
  f2:	5d 9a       	sbi	0x0b, 5	; 11
  f4:	c4 fd       	sbrc	r28, 4
  f6:	5c 9a       	sbi	0x0b, 4	; 11
  f8:	0e 94 5d 00 	call	0xba	; 0xba <toggle_e>
  fc:	5f 98       	cbi	0x0b, 7	; 11
  fe:	5e 98       	cbi	0x0b, 6	; 11
 100:	5d 98       	cbi	0x0b, 5	; 11
 102:	5c 98       	cbi	0x0b, 4	; 11
 104:	c3 fd       	sbrc	r28, 3
 106:	5f 9a       	sbi	0x0b, 7	; 11
 108:	c2 fd       	sbrc	r28, 2
 10a:	5e 9a       	sbi	0x0b, 6	; 11
 10c:	c1 fd       	sbrc	r28, 1
 10e:	5d 9a       	sbi	0x0b, 5	; 11
 110:	c0 fd       	sbrc	r28, 0
 112:	5c 9a       	sbi	0x0b, 4	; 11
 114:	0e 94 5d 00 	call	0xba	; 0xba <toggle_e>
 118:	5c 9a       	sbi	0x0b, 4	; 11
 11a:	5d 9a       	sbi	0x0b, 5	; 11
 11c:	5e 9a       	sbi	0x0b, 6	; 11
 11e:	5f 9a       	sbi	0x0b, 7	; 11
 120:	87 eb       	ldi	r24, 0xB7	; 183
 122:	9b e0       	ldi	r25, 0x0B	; 11
 124:	01 97       	sbiw	r24, 0x01	; 1
 126:	f1 f7       	brne	.-4      	; 0x124 <lcd_write+0x5c>
 128:	00 c0       	rjmp	.+0      	; 0x12a <lcd_write+0x62>
 12a:	00 00       	nop
 12c:	cf 91       	pop	r28
 12e:	08 95       	ret

00000130 <lcd_command>:
 130:	60 e0       	ldi	r22, 0x00	; 0
 132:	0e 94 64 00 	call	0xc8	; 0xc8 <lcd_write>
 136:	08 95       	ret

00000138 <lcd_data>:
 138:	61 e0       	ldi	r22, 0x01	; 1
 13a:	0e 94 64 00 	call	0xc8	; 0xc8 <lcd_write>
 13e:	08 95       	ret

00000140 <lcd_gotoxy>:
 140:	61 11       	cpse	r22, r1
 142:	04 c0       	rjmp	.+8      	; 0x14c <lcd_gotoxy+0xc>
 144:	80 58       	subi	r24, 0x80	; 128
 146:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
 14a:	08 95       	ret
 14c:	80 54       	subi	r24, 0x40	; 64
 14e:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
 152:	08 95       	ret

00000154 <lcd_clrscr>:
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
 15a:	08 95       	ret

0000015c <lcd_putc>:
 15c:	61 e0       	ldi	r22, 0x01	; 1
 15e:	0e 94 64 00 	call	0xc8	; 0xc8 <lcd_write>
 162:	08 95       	ret

00000164 <lcd_puts>:
 164:	cf 93       	push	r28
 166:	df 93       	push	r29
 168:	ec 01       	movw	r28, r24
 16a:	21 96       	adiw	r28, 0x01	; 1
 16c:	fc 01       	movw	r30, r24
 16e:	80 81       	ld	r24, Z
 170:	88 23       	and	r24, r24
 172:	29 f0       	breq	.+10     	; 0x17e <lcd_puts+0x1a>
 174:	0e 94 ae 00 	call	0x15c	; 0x15c <lcd_putc>
 178:	89 91       	ld	r24, Y+
 17a:	81 11       	cpse	r24, r1
 17c:	fb cf       	rjmp	.-10     	; 0x174 <lcd_puts+0x10>
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	08 95       	ret

00000184 <lcd_init>:
*                  LCD_DISP_ON_CURSOR      display on, cursor on
*                  LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
*  Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 184:	cf 93       	push	r28
 186:	c8 2f       	mov	r28, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
 188:	20 9a       	sbi	0x04, 0	; 4
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
 18a:	55 9a       	sbi	0x0a, 5	; 10
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
 18c:	21 9a       	sbi	0x04, 1	; 4
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
 18e:	54 9a       	sbi	0x0a, 4	; 10
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
 190:	55 9a       	sbi	0x0a, 5	; 10
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
 192:	56 9a       	sbi	0x0a, 6	; 10
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
 194:	57 9a       	sbi	0x0a, 7	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 196:	8f ef       	ldi	r24, 0xFF	; 255
 198:	99 ef       	ldi	r25, 0xF9	; 249
 19a:	01 97       	sbiw	r24, 0x01	; 1
 19c:	f1 f7       	brne	.-4      	; 0x19a <lcd_init+0x16>
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <lcd_init+0x1c>
 1a0:	00 00       	nop
    }
    delay(LCD_DELAY_BOOTUP); /* wait 16ms or more after power-on       */

    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN); // LCD_FUNCTION>>4;
 1a2:	5d 9a       	sbi	0x0b, 5	; 11
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN); // LCD_FUNCTION_8BIT>>4;
 1a4:	5c 9a       	sbi	0x0b, 4	; 11
    lcd_e_toggle();
 1a6:	0e 94 5d 00 	call	0xba	; 0xba <toggle_e>
 1aa:	8f e1       	ldi	r24, 0x1F	; 31
 1ac:	9e e4       	ldi	r25, 0x4E	; 78
 1ae:	01 97       	sbiw	r24, 0x01	; 1
 1b0:	f1 f7       	brne	.-4      	; 0x1ae <lcd_init+0x2a>
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <lcd_init+0x30>
 1b4:	00 00       	nop
    delay(LCD_DELAY_INIT); /* delay, busy flag can't be checked here */

    /* repeat last command */
    lcd_e_toggle();
 1b6:	0e 94 5d 00 	call	0xba	; 0xba <toggle_e>
 1ba:	8f ef       	ldi	r24, 0xFF	; 255
 1bc:	90 e0       	ldi	r25, 0x00	; 0
 1be:	01 97       	sbiw	r24, 0x01	; 1
 1c0:	f1 f7       	brne	.-4      	; 0x1be <lcd_init+0x3a>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <lcd_init+0x40>
 1c4:	00 00       	nop
    delay(LCD_DELAY_INIT_REP); /* delay, busy flag can't be checked here */

    /* repeat last command a third time */
    lcd_e_toggle();
 1c6:	0e 94 5d 00 	call	0xba	; 0xba <toggle_e>
 1ca:	8f ef       	ldi	r24, 0xFF	; 255
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	01 97       	sbiw	r24, 0x01	; 1
 1d0:	f1 f7       	brne	.-4      	; 0x1ce <lcd_init+0x4a>
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <lcd_init+0x50>
 1d4:	00 00       	nop
    delay(LCD_DELAY_INIT_REP); /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN); // LCD_FUNCTION_4BIT_1LINE>>4
 1d6:	5c 98       	cbi	0x0b, 4	; 11
    lcd_e_toggle();
 1d8:	0e 94 5d 00 	call	0xba	; 0xba <toggle_e>
 1dc:	8f ef       	ldi	r24, 0xFF	; 255
 1de:	90 e0       	ldi	r25, 0x00	; 0
 1e0:	01 97       	sbiw	r24, 0x01	; 1
 1e2:	f1 f7       	brne	.-4      	; 0x1e0 <lcd_init+0x5c>
 1e4:	00 c0       	rjmp	.+0      	; 0x1e6 <lcd_init+0x62>
 1e6:	00 00       	nop
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
    lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
    lcd_command(KS0073_4LINES_MODE);
    lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
    #else
    lcd_command(LCD_FUNCTION_DEFAULT); /* function set: display lines  */
 1e8:	88 e2       	ldi	r24, 0x28	; 40
 1ea:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
    #endif
    lcd_command(LCD_DISP_OFF);     /* display off                  */
 1ee:	88 e0       	ldi	r24, 0x08	; 8
 1f0:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
    lcd_clrscr();                  /* display clear                */
 1f4:	0e 94 aa 00 	call	0x154	; 0x154 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT); /* set entry mode               */
 1f8:	86 e0       	ldi	r24, 0x06	; 6
 1fa:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
    lcd_command(dispAttr);         /* display/cursor control       */
 1fe:	8c 2f       	mov	r24, r28
 200:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
}/* lcd_init */
 204:	cf 91       	pop	r28
 206:	08 95       	ret

00000208 <reset>:
* @brief performs reset of the machine to the default state
* @return none
* @par Resets the display and prepares it for the GET_CODE state.
*/
void reset(void)
{
 208:	0f 93       	push	r16
 20a:	1f 93       	push	r17
 20c:	cf 93       	push	r28
 20e:	df 93       	push	r29
	// Set pointer to beginning of CGRAM memory
	lcd_command(1 << LCD_CGRAM);
 210:	80 e4       	ldi	r24, 0x40	; 64
 212:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>
 216:	c4 e0       	ldi	r28, 0x04	; 4
 218:	d1 e0       	ldi	r29, 0x01	; 1
 21a:	04 e1       	ldi	r16, 0x14	; 20
 21c:	11 e0       	ldi	r17, 0x01	; 1
	for (uint8_t i = 0; i < 8*2; i++) //0,1,2,3 ,4,5,6,7
	{
		// Store all new chars to memory line by line
		lcd_data(customChar[i]);
 21e:	89 91       	ld	r24, Y+
 220:	0e 94 9c 00 	call	0x138	; 0x138 <lcd_data>
*/
void reset(void)
{
	// Set pointer to beginning of CGRAM memory
	lcd_command(1 << LCD_CGRAM);
	for (uint8_t i = 0; i < 8*2; i++) //0,1,2,3 ,4,5,6,7
 224:	c0 17       	cp	r28, r16
 226:	d1 07       	cpc	r29, r17
 228:	d1 f7       	brne	.-12     	; 0x21e <reset+0x16>
	{
		// Store all new chars to memory line by line
		lcd_data(customChar[i]);
	}
	// Set DDRAM address
	lcd_command(1 << LCD_DDRAM);
 22a:	80 e8       	ldi	r24, 0x80	; 128
 22c:	0e 94 98 00 	call	0x130	; 0x130 <lcd_command>

	// Initialize LCD display
	lcd_clrscr();
 230:	0e 94 aa 00 	call	0x154	; 0x154 <lcd_clrscr>
	// Display custom characters
	lcd_putc(0);
 234:	80 e0       	ldi	r24, 0x00	; 0
 236:	0e 94 ae 00 	call	0x15c	; 0x15c <lcd_putc>
	lcd_gotoxy(15, 0);
 23a:	60 e0       	ldi	r22, 0x00	; 0
 23c:	8f e0       	ldi	r24, 0x0F	; 15
 23e:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
	lcd_putc(0);
 242:	80 e0       	ldi	r24, 0x00	; 0
 244:	0e 94 ae 00 	call	0x15c	; 0x15c <lcd_putc>
	lcd_gotoxy(0, 1);
 248:	61 e0       	ldi	r22, 0x01	; 1
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
	lcd_putc(1);
 250:	81 e0       	ldi	r24, 0x01	; 1
 252:	0e 94 ae 00 	call	0x15c	; 0x15c <lcd_putc>
	lcd_gotoxy(15, 1);
 256:	61 e0       	ldi	r22, 0x01	; 1
 258:	8f e0       	ldi	r24, 0x0F	; 15
 25a:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
	lcd_putc(1);
 25e:	81 e0       	ldi	r24, 0x01	; 1
 260:	0e 94 ae 00 	call	0x15c	; 0x15c <lcd_putc>
	

	lcd_gotoxy(1, 0);
 264:	60 e0       	ldi	r22, 0x00	; 0
 266:	81 e0       	ldi	r24, 0x01	; 1
 268:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
	lcd_puts("Password:____");
 26c:	80 e2       	ldi	r24, 0x20	; 32
 26e:	91 e0       	ldi	r25, 0x01	; 1
 270:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
	//_delay_ms(2000);
}
 274:	df 91       	pop	r29
 276:	cf 91       	pop	r28
 278:	1f 91       	pop	r17
 27a:	0f 91       	pop	r16
 27c:	08 95       	ret

0000027e <getkey>:
* @return Numbers 0 to 12
* @par Enables high output value on three pins connected to columns one by one, checking each time all the pins connected to rows again one by one. 
If it detects output, it returns the unique number assigned to every combination of a row and a column pin. If it doesn't detect any connection, it returns 0.
*/
uint8_t getkey()
{
 27e:	cf 92       	push	r12
 280:	df 92       	push	r13
 282:	ef 92       	push	r14
 284:	ff 92       	push	r15
 286:	0f 93       	push	r16
 288:	1f 93       	push	r17
 28a:	cf 93       	push	r28
 28c:	df 93       	push	r29
	uint8_t row, col;
	DDRC&=~(0x7F);
 28e:	87 b1       	in	r24, 0x07	; 7
 290:	80 78       	andi	r24, 0x80	; 128
 292:	87 b9       	out	0x07, r24	; 7
	PORTC|=0x0F;
 294:	88 b1       	in	r24, 0x08	; 8
 296:	8f 60       	ori	r24, 0x0F	; 15
 298:	88 b9       	out	0x08, r24	; 8
 29a:	00 e0       	ldi	r16, 0x00	; 0
 29c:	10 e0       	ldi	r17, 0x00	; 0
	for(col=0;col<3;col++)
	{
		DDRC|=(0x10<<col);
 29e:	68 94       	set
 2a0:	cc 24       	eor	r12, r12
 2a2:	c4 f8       	bld	r12, 4
 2a4:	d1 2c       	mov	r13, r1
 2a6:	d0 2f       	mov	r29, r16
 2a8:	97 b1       	in	r25, 0x07	; 7
 2aa:	76 01       	movw	r14, r12
 2ac:	00 2e       	mov	r0, r16
 2ae:	02 c0       	rjmp	.+4      	; 0x2b4 <getkey+0x36>
 2b0:	ee 0c       	add	r14, r14
 2b2:	ff 1c       	adc	r15, r15
 2b4:	0a 94       	dec	r0
 2b6:	e2 f7       	brpl	.-8      	; 0x2b0 <getkey+0x32>
 2b8:	9e 29       	or	r25, r14
 2ba:	97 b9       	out	0x07, r25	; 7
		if(!GPIO_read(&PINC, 0))
 2bc:	60 e0       	ldi	r22, 0x00	; 0
 2be:	86 e2       	ldi	r24, 0x26	; 38
 2c0:	90 e0       	ldi	r25, 0x00	; 0
 2c2:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_read>
 2c6:	88 23       	and	r24, r24
 2c8:	e9 f0       	breq	.+58     	; 0x304 <getkey+0x86>
 2ca:	c0 e0       	ldi	r28, 0x00	; 0
			return(-1);
		for(row=0;row<4;row++)
			if(!GPIO_read(&PINC, row))
 2cc:	6c 2f       	mov	r22, r28
 2ce:	86 e2       	ldi	r24, 0x26	; 38
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	0e 94 53 00 	call	0xa6	; 0xa6 <GPIO_read>
 2d6:	81 11       	cpse	r24, r1
 2d8:	07 c0       	rjmp	.+14     	; 0x2e8 <getkey+0x6a>
				return(row*3+col+1);
 2da:	8c 2f       	mov	r24, r28
 2dc:	88 0f       	add	r24, r24
 2de:	c8 0f       	add	r28, r24
 2e0:	81 e0       	ldi	r24, 0x01	; 1
 2e2:	8d 0f       	add	r24, r29
 2e4:	8c 0f       	add	r24, r28
 2e6:	0f c0       	rjmp	.+30     	; 0x306 <getkey+0x88>
	for(col=0;col<3;col++)
	{
		DDRC|=(0x10<<col);
		if(!GPIO_read(&PINC, 0))
			return(-1);
		for(row=0;row<4;row++)
 2e8:	cf 5f       	subi	r28, 0xFF	; 255
 2ea:	c4 30       	cpi	r28, 0x04	; 4
 2ec:	79 f7       	brne	.-34     	; 0x2cc <getkey+0x4e>
			if(!GPIO_read(&PINC, row))
				return(row*3+col+1);
		DDRC&=~(0x10<<col);
 2ee:	87 b1       	in	r24, 0x07	; 7
 2f0:	e0 94       	com	r14
 2f2:	e8 22       	and	r14, r24
 2f4:	e7 b8       	out	0x07, r14	; 7
 2f6:	0f 5f       	subi	r16, 0xFF	; 255
 2f8:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t getkey()
{
	uint8_t row, col;
	DDRC&=~(0x7F);
	PORTC|=0x0F;
	for(col=0;col<3;col++)
 2fa:	03 30       	cpi	r16, 0x03	; 3
 2fc:	11 05       	cpc	r17, r1
 2fe:	99 f6       	brne	.-90     	; 0x2a6 <getkey+0x28>
		for(row=0;row<4;row++)
			if(!GPIO_read(&PINC, row))
				return(row*3+col+1);
		DDRC&=~(0x10<<col);
	}
	return 0;//Indicate No key pressed
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	01 c0       	rjmp	.+2      	; 0x306 <getkey+0x88>
	PORTC|=0x0F;
	for(col=0;col<3;col++)
	{
		DDRC|=(0x10<<col);
		if(!GPIO_read(&PINC, 0))
			return(-1);
 304:	8f ef       	ldi	r24, 0xFF	; 255
			if(!GPIO_read(&PINC, row))
				return(row*3+col+1);
		DDRC&=~(0x10<<col);
	}
	return 0;//Indicate No key pressed
}
 306:	df 91       	pop	r29
 308:	cf 91       	pop	r28
 30a:	1f 91       	pop	r17
 30c:	0f 91       	pop	r16
 30e:	ff 90       	pop	r15
 310:	ef 90       	pop	r14
 312:	df 90       	pop	r13
 314:	cf 90       	pop	r12
 316:	08 95       	ret

00000318 <get_code>:
* @return None
* @par Constantly runs the getkey() function, checking for input from the keypad. If there is any, operates with it - puts numbers in the code, if it is not full,
 deletes, if the '*'(backspace) character is used and sends the code to be checked if the '#'(enter) is used. Also limits the time to put in the code to 20s.
*/
void get_code(uint8_t* code)
{
 318:	0f 93       	push	r16
 31a:	1f 93       	push	r17
 31c:	cf 93       	push	r28
 31e:	df 93       	push	r29
 320:	00 d0       	rcall	.+0      	; 0x322 <get_code+0xa>
 322:	00 d0       	rcall	.+0      	; 0x324 <get_code+0xc>
 324:	1f 92       	push	r1
 326:	cd b7       	in	r28, 0x3d	; 61
 328:	de b7       	in	r29, 0x3e	; 62
 32a:	8c 01       	movw	r16, r24
	if(code[0] != 10)
 32c:	fc 01       	movw	r30, r24
 32e:	80 81       	ld	r24, Z
 330:	8a 30       	cpi	r24, 0x0A	; 10
 332:	51 f0       	breq	.+20     	; 0x348 <get_code+0x30>
	{		
		TIM2_overflow_16ms();
 334:	e1 eb       	ldi	r30, 0xB1	; 177
 336:	f0 e0       	ldi	r31, 0x00	; 0
 338:	80 81       	ld	r24, Z
 33a:	87 60       	ori	r24, 0x07	; 7
 33c:	80 83       	st	Z, r24
		TIM2_overflow_interrupt_enable();	
 33e:	e0 e7       	ldi	r30, 0x70	; 112
 340:	f0 e0       	ldi	r31, 0x00	; 0
 342:	80 81       	ld	r24, Z
 344:	81 60       	ori	r24, 0x01	; 1
 346:	80 83       	st	Z, r24
	}
	
	uint8_t key = getkey();
 348:	0e 94 3f 01 	call	0x27e	; 0x27e <getkey>
	if (key!=0)
 34c:	88 23       	and	r24, r24
 34e:	09 f4       	brne	.+2      	; 0x352 <get_code+0x3a>
 350:	4b c0       	rjmp	.+150    	; 0x3e8 <get_code+0xd0>
	{
		switch(key)
 352:	8a 30       	cpi	r24, 0x0A	; 10
 354:	19 f0       	breq	.+6      	; 0x35c <get_code+0x44>
 356:	8c 30       	cpi	r24, 0x0C	; 12
 358:	61 f0       	breq	.+24     	; 0x372 <get_code+0x5a>
 35a:	06 c0       	rjmp	.+12     	; 0x368 <get_code+0x50>
				TIM2_overflow_interrupt_disable();
				current_state = CHECK_CODE; //ma se provest kontrola hesla a pripadne dalsi zmeny
				break;
			case 10:
				for(uint8_t i=3;i>=0;i--)
					if(code[i]!=10)
 35c:	f8 01       	movw	r30, r16
 35e:	83 81       	ldd	r24, Z+3	; 0x03
 360:	8a 30       	cpi	r24, 0x0A	; 10
 362:	81 f4       	brne	.+32     	; 0x384 <get_code+0x6c>
 364:	83 e0       	ldi	r24, 0x03	; 3
 366:	1c c0       	rjmp	.+56     	; 0x3a0 <get_code+0x88>
					}
				_delay_ms(250);
					break;
			default:
				for(uint8_t j=0;j<4;j++)
					if(code[j]==10)
 368:	f8 01       	movw	r30, r16
 36a:	90 81       	ld	r25, Z
 36c:	9a 30       	cpi	r25, 0x0A	; 10
 36e:	01 f5       	brne	.+64     	; 0x3b0 <get_code+0x98>
 370:	2c c0       	rjmp	.+88     	; 0x3ca <get_code+0xb2>
	if (key!=0)
	{
		switch(key)
		{
			case 12:
				TIM2_overflow_interrupt_disable();
 372:	e0 e7       	ldi	r30, 0x70	; 112
 374:	f0 e0       	ldi	r31, 0x00	; 0
 376:	80 81       	ld	r24, Z
 378:	8e 7f       	andi	r24, 0xFE	; 254
 37a:	80 83       	st	Z, r24
				current_state = CHECK_CODE; //ma se provest kontrola hesla a pripadne dalsi zmeny
 37c:	82 e0       	ldi	r24, 0x02	; 2
 37e:	80 93 bb 01 	sts	0x01BB, r24	; 0x8001bb <current_state>
				break;
 382:	32 c0       	rjmp	.+100    	; 0x3e8 <get_code+0xd0>
			case 10:
				for(uint8_t i=3;i>=0;i--)
					if(code[i]!=10)
 384:	f8 01       	movw	r30, r16
 386:	33 96       	adiw	r30, 0x03	; 3
					{
						code[i]=10;
 388:	8a e0       	ldi	r24, 0x0A	; 10
 38a:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 38c:	ff ef       	ldi	r31, 0xFF	; 255
 38e:	24 e3       	ldi	r18, 0x34	; 52
 390:	8c e0       	ldi	r24, 0x0C	; 12
 392:	f1 50       	subi	r31, 0x01	; 1
 394:	20 40       	sbci	r18, 0x00	; 0
 396:	80 40       	sbci	r24, 0x00	; 0
 398:	e1 f7       	brne	.-8      	; 0x392 <get_code+0x7a>
 39a:	00 c0       	rjmp	.+0      	; 0x39c <get_code+0x84>
 39c:	00 00       	nop
 39e:	24 c0       	rjmp	.+72     	; 0x3e8 <get_code+0xd0>
			case 12:
				TIM2_overflow_interrupt_disable();
				current_state = CHECK_CODE; //ma se provest kontrola hesla a pripadne dalsi zmeny
				break;
			case 10:
				for(uint8_t i=3;i>=0;i--)
 3a0:	81 50       	subi	r24, 0x01	; 1
					if(code[i]!=10)
 3a2:	f8 01       	movw	r30, r16
 3a4:	e8 0f       	add	r30, r24
 3a6:	f1 1d       	adc	r31, r1
 3a8:	90 81       	ld	r25, Z
 3aa:	9a 30       	cpi	r25, 0x0A	; 10
 3ac:	c9 f3       	breq	.-14     	; 0x3a0 <get_code+0x88>
 3ae:	ec cf       	rjmp	.-40     	; 0x388 <get_code+0x70>
 3b0:	98 01       	movw	r18, r16
 3b2:	2f 5f       	subi	r18, 0xFF	; 255
 3b4:	3f 4f       	sbci	r19, 0xFF	; 255
 3b6:	a8 01       	movw	r20, r16
 3b8:	4c 5f       	subi	r20, 0xFC	; 252
 3ba:	5f 4f       	sbci	r21, 0xFF	; 255
					}
				_delay_ms(250);
					break;
			default:
				for(uint8_t j=0;j<4;j++)
					if(code[j]==10)
 3bc:	f9 01       	movw	r30, r18
 3be:	2f 5f       	subi	r18, 0xFF	; 255
 3c0:	3f 4f       	sbci	r19, 0xFF	; 255
 3c2:	90 81       	ld	r25, Z
 3c4:	9a 30       	cpi	r25, 0x0A	; 10
 3c6:	21 f4       	brne	.+8      	; 0x3d0 <get_code+0xb8>
 3c8:	01 c0       	rjmp	.+2      	; 0x3cc <get_code+0xb4>
 3ca:	f8 01       	movw	r30, r16
					{
						code[j]=key;
 3cc:	80 83       	st	Z, r24
						break;
 3ce:	03 c0       	rjmp	.+6      	; 0x3d6 <get_code+0xbe>
						break;
					}
				_delay_ms(250);
					break;
			default:
				for(uint8_t j=0;j<4;j++)
 3d0:	42 17       	cp	r20, r18
 3d2:	53 07       	cpc	r21, r19
 3d4:	99 f7       	brne	.-26     	; 0x3bc <get_code+0xa4>
 3d6:	9f ef       	ldi	r25, 0xFF	; 255
 3d8:	e4 e3       	ldi	r30, 0x34	; 52
 3da:	fc e0       	ldi	r31, 0x0C	; 12
 3dc:	91 50       	subi	r25, 0x01	; 1
 3de:	e0 40       	sbci	r30, 0x00	; 0
 3e0:	f0 40       	sbci	r31, 0x00	; 0
 3e2:	e1 f7       	brne	.-8      	; 0x3dc <get_code+0xc4>
 3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <get_code+0xce>
 3e6:	00 00       	nop
				_delay_ms(250);
		} //pokud nedochazi ke kontrole hesla, je treba vlozit malou pauzu (cca 0,5s), aby nedochazelo k duplikaci stisknuteho tlacitka
	}
	
	
	if(code[0] == 10)
 3e8:	f8 01       	movw	r30, r16
 3ea:	80 81       	ld	r24, Z
 3ec:	8a 30       	cpi	r24, 0x0A	; 10
 3ee:	69 f4       	brne	.+26     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
	{
		TIM2_overflow_interrupt_disable();
 3f0:	e0 e7       	ldi	r30, 0x70	; 112
 3f2:	f0 e0       	ldi	r31, 0x00	; 0
 3f4:	80 81       	ld	r24, Z
 3f6:	8e 7f       	andi	r24, 0xFE	; 254
 3f8:	80 83       	st	Z, r24
		counter2 = 0;
 3fa:	10 92 b7 01 	sts	0x01B7, r1	; 0x8001b7 <counter2>
 3fe:	10 92 b8 01 	sts	0x01B8, r1	; 0x8001b8 <counter2+0x1>
 402:	10 92 b9 01 	sts	0x01B9, r1	; 0x8001b9 <counter2+0x2>
 406:	10 92 ba 01 	sts	0x01BA, r1	; 0x8001ba <counter2+0x3>
	}	
	
	char password[] = "    ";
 40a:	85 e0       	ldi	r24, 0x05	; 5
 40c:	ee e2       	ldi	r30, 0x2E	; 46
 40e:	f1 e0       	ldi	r31, 0x01	; 1
 410:	de 01       	movw	r26, r28
 412:	11 96       	adiw	r26, 0x01	; 1
 414:	01 90       	ld	r0, Z+
 416:	0d 92       	st	X+, r0
 418:	8a 95       	dec	r24
 41a:	e1 f7       	brne	.-8      	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
    lcd_gotoxy(10, 0);
 41c:	60 e0       	ldi	r22, 0x00	; 0
 41e:	8a e0       	ldi	r24, 0x0A	; 10
 420:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
 424:	d8 01       	movw	r26, r16
 426:	fe 01       	movw	r30, r28
 428:	31 96       	adiw	r30, 0x01	; 1
 42a:	9e 01       	movw	r18, r28
 42c:	2b 5f       	subi	r18, 0xFB	; 251
 42e:	3f 4f       	sbci	r19, 0xFF	; 255
    for(uint8_t i = 0; i < 4; i++){
        password[i] = (code[i] == 10)? '_': '*';
 430:	8d 91       	ld	r24, X+
 432:	8a 30       	cpi	r24, 0x0A	; 10
 434:	11 f0       	breq	.+4      	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
 436:	8a e2       	ldi	r24, 0x2A	; 42
 438:	01 c0       	rjmp	.+2      	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
 43a:	8f e5       	ldi	r24, 0x5F	; 95
 43c:	81 93       	st	Z+, r24
		counter2 = 0;
	}	
	
	char password[] = "    ";
    lcd_gotoxy(10, 0);
    for(uint8_t i = 0; i < 4; i++){
 43e:	e2 17       	cp	r30, r18
 440:	f3 07       	cpc	r31, r19
 442:	b1 f7       	brne	.-20     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
        password[i] = (code[i] == 10)? '_': '*';
    }
    lcd_puts(password);   
 444:	ce 01       	movw	r24, r28
 446:	01 96       	adiw	r24, 0x01	; 1
 448:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
}
 44c:	0f 90       	pop	r0
 44e:	0f 90       	pop	r0
 450:	0f 90       	pop	r0
 452:	0f 90       	pop	r0
 454:	0f 90       	pop	r0
 456:	df 91       	pop	r29
 458:	cf 91       	pop	r28
 45a:	1f 91       	pop	r17
 45c:	0f 91       	pop	r16
 45e:	08 95       	ret

00000460 <check_code>:
/**
* @brief Checks, if the correct code has been entered
* @return true(1) or false (0)
*/
bool check_code(uint8_t* code)
{
 460:	ef 92       	push	r14
 462:	ff 92       	push	r15
 464:	1f 93       	push	r17
 466:	cf 93       	push	r28
 468:	df 93       	push	r29
 46a:	cd b7       	in	r28, 0x3d	; 61
 46c:	de b7       	in	r29, 0x3e	; 62
 46e:	6a 97       	sbiw	r28, 0x1a	; 26
 470:	0f b6       	in	r0, 0x3f	; 63
 472:	f8 94       	cli
 474:	de bf       	out	0x3e, r29	; 62
 476:	0f be       	out	0x3f, r0	; 63
 478:	cd bf       	out	0x3d, r28	; 61
 47a:	7c 01       	movw	r14, r24
	char welcome[] = "Welcome UserX";
 47c:	8e e0       	ldi	r24, 0x0E	; 14
 47e:	e2 e4       	ldi	r30, 0x42	; 66
 480:	f1 e0       	ldi	r31, 0x01	; 1
 482:	de 01       	movw	r26, r28
 484:	11 96       	adiw	r26, 0x01	; 1
 486:	01 90       	ld	r0, Z+
 488:	0d 92       	st	X+, r0
 48a:	8a 95       	dec	r24
 48c:	e1 f7       	brne	.-8      	; 0x486 <check_code+0x26>
	uint8_t correct_counter = 0;
	//codes are 4242, 0123, 9876
	uint8_t correct_password[3][4] = {{4,2,4,2},{11,1,2,3},{9,8,7,6}};
 48e:	8c e0       	ldi	r24, 0x0C	; 12
 490:	e4 e1       	ldi	r30, 0x14	; 20
 492:	f1 e0       	ldi	r31, 0x01	; 1
 494:	de 01       	movw	r26, r28
 496:	1f 96       	adiw	r26, 0x0f	; 15
 498:	01 90       	ld	r0, Z+
 49a:	0d 92       	st	X+, r0
 49c:	8a 95       	dec	r24
 49e:	e1 f7       	brne	.-8      	; 0x498 <check_code+0x38>
 4a0:	be 01       	movw	r22, r28
 4a2:	61 5f       	subi	r22, 0xF1	; 241
 4a4:	7f 4f       	sbci	r23, 0xFF	; 255
	for(uint8_t i = 0;i < 3; i++)
 4a6:	10 e0       	ldi	r17, 0x00	; 0
* @return true(1) or false (0)
*/
bool check_code(uint8_t* code)
{
	char welcome[] = "Welcome UserX";
	uint8_t correct_counter = 0;
 4a8:	30 e0       	ldi	r19, 0x00	; 0
 4aa:	a7 01       	movw	r20, r14
 4ac:	4c 5f       	subi	r20, 0xFC	; 252
 4ae:	5f 4f       	sbci	r21, 0xFF	; 255
 4b0:	23 c0       	rjmp	.+70     	; 0x4f8 <check_code+0x98>
	//codes are 4242, 0123, 9876
	uint8_t correct_password[3][4] = {{4,2,4,2},{11,1,2,3},{9,8,7,6}};
	for(uint8_t i = 0;i < 3; i++)
	{
		for(uint8_t j = 0; j < 4; j++)
			if(correct_password[i][j] == code[j])
 4b2:	2d 91       	ld	r18, X+
 4b4:	91 91       	ld	r25, Z+
 4b6:	29 13       	cpse	r18, r25
 4b8:	01 c0       	rjmp	.+2      	; 0x4bc <check_code+0x5c>
				correct_counter++;
 4ba:	3f 5f       	subi	r19, 0xFF	; 255
	uint8_t correct_counter = 0;
	//codes are 4242, 0123, 9876
	uint8_t correct_password[3][4] = {{4,2,4,2},{11,1,2,3},{9,8,7,6}};
	for(uint8_t i = 0;i < 3; i++)
	{
		for(uint8_t j = 0; j < 4; j++)
 4bc:	e4 17       	cp	r30, r20
 4be:	f5 07       	cpc	r31, r21
 4c0:	c1 f7       	brne	.-16     	; 0x4b2 <check_code+0x52>
			if(correct_password[i][j] == code[j])
				correct_counter++;
		if(correct_counter == 4)
 4c2:	34 30       	cpi	r19, 0x04	; 4
 4c4:	a1 f4       	brne	.+40     	; 0x4ee <check_code+0x8e>
		{
			lcd_gotoxy(1, 0);
 4c6:	60 e0       	ldi	r22, 0x00	; 0
 4c8:	81 e0       	ldi	r24, 0x01	; 1
 4ca:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
			lcd_puts("ACCESS GRANTED");
 4ce:	83 e3       	ldi	r24, 0x33	; 51
 4d0:	91 e0       	ldi	r25, 0x01	; 1
 4d2:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
			lcd_gotoxy(1, 1);
 4d6:	61 e0       	ldi	r22, 0x01	; 1
 4d8:	81 e0       	ldi	r24, 0x01	; 1
 4da:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
			welcome[12] = (char) i + '0';
 4de:	10 5d       	subi	r17, 0xD0	; 208
 4e0:	1d 87       	std	Y+13, r17	; 0x0d
			lcd_puts(welcome);
 4e2:	ce 01       	movw	r24, r28
 4e4:	01 96       	adiw	r24, 0x01	; 1
 4e6:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
			return 1;
 4ea:	81 e0       	ldi	r24, 0x01	; 1
 4ec:	09 c0       	rjmp	.+18     	; 0x500 <check_code+0xa0>
{
	char welcome[] = "Welcome UserX";
	uint8_t correct_counter = 0;
	//codes are 4242, 0123, 9876
	uint8_t correct_password[3][4] = {{4,2,4,2},{11,1,2,3},{9,8,7,6}};
	for(uint8_t i = 0;i < 3; i++)
 4ee:	1f 5f       	subi	r17, 0xFF	; 255
 4f0:	6c 5f       	subi	r22, 0xFC	; 252
 4f2:	7f 4f       	sbci	r23, 0xFF	; 255
 4f4:	13 30       	cpi	r17, 0x03	; 3
 4f6:	19 f0       	breq	.+6      	; 0x4fe <check_code+0x9e>
 4f8:	f7 01       	movw	r30, r14
/**
* @brief Checks, if the correct code has been entered
* @return true(1) or false (0)
*/
bool check_code(uint8_t* code)
{
 4fa:	db 01       	movw	r26, r22
 4fc:	da cf       	rjmp	.-76     	; 0x4b2 <check_code+0x52>
			welcome[12] = (char) i + '0';
			lcd_puts(welcome);
			return 1;
		}
	}
	return 0;
 4fe:	80 e0       	ldi	r24, 0x00	; 0
}
 500:	6a 96       	adiw	r28, 0x1a	; 26
 502:	0f b6       	in	r0, 0x3f	; 63
 504:	f8 94       	cli
 506:	de bf       	out	0x3e, r29	; 62
 508:	0f be       	out	0x3f, r0	; 63
 50a:	cd bf       	out	0x3d, r28	; 61
 50c:	df 91       	pop	r29
 50e:	cf 91       	pop	r28
 510:	1f 91       	pop	r17
 512:	ff 90       	pop	r15
 514:	ef 90       	pop	r14
 516:	08 95       	ret

00000518 <state_machine>:
* @return None
*/
void state_machine(void)
{
	static uint8_t code[4]={10,10,10,10};
	switch (current_state)
 518:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <current_state>
 51c:	82 30       	cpi	r24, 0x02	; 2
 51e:	d9 f0       	breq	.+54     	; 0x556 <state_machine+0x3e>
 520:	28 f4       	brcc	.+10     	; 0x52c <state_machine+0x14>
 522:	88 23       	and	r24, r24
 524:	31 f0       	breq	.+12     	; 0x532 <state_machine+0x1a>
 526:	81 30       	cpi	r24, 0x01	; 1
 528:	89 f0       	breq	.+34     	; 0x54c <state_machine+0x34>
 52a:	31 c0       	rjmp	.+98     	; 0x58e <state_machine+0x76>
 52c:	85 30       	cpi	r24, 0x05	; 5
 52e:	88 f1       	brcs	.+98     	; 0x592 <state_machine+0x7a>
 530:	2e c0       	rjmp	.+92     	; 0x58e <state_machine+0x76>
	{
		case RESET:
			reset();
 532:	0e 94 04 01 	call	0x208	; 0x208 <reset>
			for(uint8_t i = 0; i < 4; i++)
				code[i]=10;
 536:	e0 e0       	ldi	r30, 0x00	; 0
 538:	f1 e0       	ldi	r31, 0x01	; 1
 53a:	8a e0       	ldi	r24, 0x0A	; 10
 53c:	80 83       	st	Z, r24
 53e:	81 83       	std	Z+1, r24	; 0x01
 540:	82 83       	std	Z+2, r24	; 0x02
 542:	83 83       	std	Z+3, r24	; 0x03
			current_state = GET_CODE;
 544:	81 e0       	ldi	r24, 0x01	; 1
 546:	80 93 bb 01 	sts	0x01BB, r24	; 0x8001bb <current_state>
			break;
 54a:	08 95       	ret
		case GET_CODE:
			get_code(code);
 54c:	80 e0       	ldi	r24, 0x00	; 0
 54e:	91 e0       	ldi	r25, 0x01	; 1
 550:	0e 94 8c 01 	call	0x318	; 0x318 <get_code>
			break;
 554:	08 95       	ret
		case CHECK_CODE:
			current_state = check_code(code)?DOOR_OPEN:WRONG_CODE;
 556:	80 e0       	ldi	r24, 0x00	; 0
 558:	91 e0       	ldi	r25, 0x01	; 1
 55a:	0e 94 30 02 	call	0x460	; 0x460 <check_code>
 55e:	81 11       	cpse	r24, r1
 560:	02 c0       	rjmp	.+4      	; 0x566 <state_machine+0x4e>
 562:	84 e0       	ldi	r24, 0x04	; 4
 564:	01 c0       	rjmp	.+2      	; 0x568 <state_machine+0x50>
 566:	83 e0       	ldi	r24, 0x03	; 3
 568:	80 93 bb 01 	sts	0x01BB, r24	; 0x8001bb <current_state>
			TIM2_overflow_interrupt_disable();
 56c:	e0 e7       	ldi	r30, 0x70	; 112
 56e:	f0 e0       	ldi	r31, 0x00	; 0
 570:	80 81       	ld	r24, Z
 572:	8e 7f       	andi	r24, 0xFE	; 254
 574:	80 83       	st	Z, r24
			TIM2_overflow_4ms();
 576:	a1 eb       	ldi	r26, 0xB1	; 177
 578:	b0 e0       	ldi	r27, 0x00	; 0
 57a:	8c 91       	ld	r24, X
 57c:	8e 7f       	andi	r24, 0xFE	; 254
 57e:	8c 93       	st	X, r24
 580:	8c 91       	ld	r24, X
 582:	86 60       	ori	r24, 0x06	; 6
 584:	8c 93       	st	X, r24
			TIM2_overflow_interrupt_enable();
 586:	80 81       	ld	r24, Z
 588:	81 60       	ori	r24, 0x01	; 1
 58a:	80 83       	st	Z, r24
			break;
 58c:	08 95       	ret
		case DOOR_OPEN:		
			break;
		case WRONG_CODE:		
			break;
		default:
			current_state = RESET;		
 58e:	10 92 bb 01 	sts	0x01BB, r1	; 0x8001bb <current_state>
 592:	08 95       	ret

00000594 <main>:
 * @brief Initializes the lcd and prepares the relay, runs state machine.
 * @return None
 */
int main(void)
{	
	DDRB|=(0x08);
 594:	23 9a       	sbi	0x04, 3	; 4
	PORTB&=~(0x08);
 596:	2b 98       	cbi	0x05, 3	; 5

	TIM0_overflow_16ms();
 598:	85 b5       	in	r24, 0x25	; 37
 59a:	8d 7f       	andi	r24, 0xFD	; 253
 59c:	85 bd       	out	0x25, r24	; 37
 59e:	85 b5       	in	r24, 0x25	; 37
 5a0:	85 60       	ori	r24, 0x05	; 5
 5a2:	85 bd       	out	0x25, r24	; 37
	TIM0_overflow_interrupt_enable();
 5a4:	ee e6       	ldi	r30, 0x6E	; 110
 5a6:	f0 e0       	ldi	r31, 0x00	; 0
 5a8:	80 81       	ld	r24, Z
 5aa:	81 60       	ori	r24, 0x01	; 1
 5ac:	80 83       	st	Z, r24
	
	TIM1_overflow_262ms();
 5ae:	e1 e8       	ldi	r30, 0x81	; 129
 5b0:	f0 e0       	ldi	r31, 0x00	; 0
 5b2:	80 81       	ld	r24, Z
 5b4:	8b 7f       	andi	r24, 0xFB	; 251
 5b6:	80 83       	st	Z, r24
 5b8:	80 81       	ld	r24, Z
 5ba:	83 60       	ori	r24, 0x03	; 3
 5bc:	80 83       	st	Z, r24
	TIM1_overflow_interrupt_enable();
 5be:	ef e6       	ldi	r30, 0x6F	; 111
 5c0:	f0 e0       	ldi	r31, 0x00	; 0
 5c2:	80 81       	ld	r24, Z
 5c4:	81 60       	ori	r24, 0x01	; 1
 5c6:	80 83       	st	Z, r24
	
	lcd_init(LCD_DISP_ON);
 5c8:	8c e0       	ldi	r24, 0x0C	; 12
 5ca:	0e 94 c2 00 	call	0x184	; 0x184 <lcd_init>
	
    // Initialize UART to asynchronous, 8N1, 9600
	uart_init(UART_BAUD_SELECT(9600, F_CPU));
 5ce:	87 e6       	ldi	r24, 0x67	; 103
 5d0:	90 e0       	ldi	r25, 0x00	; 0
 5d2:	0e 94 98 04 	call	0x930	; 0x930 <uart_init>

    // Enables interrupts by setting the global interrupt mask
    sei();
 5d6:	78 94       	sei
 5d8:	ff cf       	rjmp	.-2      	; 0x5d8 <main+0x44>

000005da <__vector_16>:
/**
 * @brief Runs the state machine
 * @return None
 */
ISR(TIMER0_OVF_vect)
{
 5da:	1f 92       	push	r1
 5dc:	0f 92       	push	r0
 5de:	0f b6       	in	r0, 0x3f	; 63
 5e0:	0f 92       	push	r0
 5e2:	11 24       	eor	r1, r1
 5e4:	2f 93       	push	r18
 5e6:	3f 93       	push	r19
 5e8:	4f 93       	push	r20
 5ea:	5f 93       	push	r21
 5ec:	6f 93       	push	r22
 5ee:	7f 93       	push	r23
 5f0:	8f 93       	push	r24
 5f2:	9f 93       	push	r25
 5f4:	af 93       	push	r26
 5f6:	bf 93       	push	r27
 5f8:	ef 93       	push	r30
 5fa:	ff 93       	push	r31
	state_machine();
 5fc:	0e 94 8c 02 	call	0x518	; 0x518 <state_machine>
}	
 600:	ff 91       	pop	r31
 602:	ef 91       	pop	r30
 604:	bf 91       	pop	r27
 606:	af 91       	pop	r26
 608:	9f 91       	pop	r25
 60a:	8f 91       	pop	r24
 60c:	7f 91       	pop	r23
 60e:	6f 91       	pop	r22
 610:	5f 91       	pop	r21
 612:	4f 91       	pop	r20
 614:	3f 91       	pop	r19
 616:	2f 91       	pop	r18
 618:	0f 90       	pop	r0
 61a:	0f be       	out	0x3f, r0	; 63
 61c:	0f 90       	pop	r0
 61e:	1f 90       	pop	r1
 620:	18 95       	reti

00000622 <__vector_13>:
/**
 * @brief Timer responsible for sending information to UART
 * @par Runs the whole time alongside the state machine, if the state of the machine is changed, timer registers that and sends the information to UART.
 */
ISR(TIMER1_OVF_vect)
{
 622:	1f 92       	push	r1
 624:	0f 92       	push	r0
 626:	0f b6       	in	r0, 0x3f	; 63
 628:	0f 92       	push	r0
 62a:	11 24       	eor	r1, r1
 62c:	2f 93       	push	r18
 62e:	3f 93       	push	r19
 630:	4f 93       	push	r20
 632:	5f 93       	push	r21
 634:	6f 93       	push	r22
 636:	7f 93       	push	r23
 638:	8f 93       	push	r24
 63a:	9f 93       	push	r25
 63c:	af 93       	push	r26
 63e:	bf 93       	push	r27
 640:	ef 93       	push	r30
 642:	ff 93       	push	r31
	static type_state prev_state = RESET;
	uart_puts("");
 644:	86 e9       	ldi	r24, 0x96	; 150
 646:	91 e0       	ldi	r25, 0x01	; 1
 648:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
	if(current_state != prev_state)
 64c:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <current_state>
 650:	80 91 b2 01 	lds	r24, 0x01B2	; 0x8001b2 <__data_end>
 654:	98 17       	cp	r25, r24
 656:	09 f4       	brne	.+2      	; 0x65a <__vector_13+0x38>
 658:	4f c0       	rjmp	.+158    	; 0x6f8 <__vector_13+0xd6>
   {
	   // Send to uart
	   uart_puts("Current state: ");
 65a:	80 e5       	ldi	r24, 0x50	; 80
 65c:	91 e0       	ldi	r25, 0x01	; 1
 65e:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
	   switch(current_state)
 662:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <current_state>
 666:	82 30       	cpi	r24, 0x02	; 2
 668:	a9 f0       	breq	.+42     	; 0x694 <__vector_13+0x72>
 66a:	28 f4       	brcc	.+10     	; 0x676 <__vector_13+0x54>
 66c:	88 23       	and	r24, r24
 66e:	41 f0       	breq	.+16     	; 0x680 <__vector_13+0x5e>
 670:	81 30       	cpi	r24, 0x01	; 1
 672:	59 f0       	breq	.+22     	; 0x68a <__vector_13+0x68>
 674:	39 c0       	rjmp	.+114    	; 0x6e8 <__vector_13+0xc6>
 676:	83 30       	cpi	r24, 0x03	; 3
 678:	91 f0       	breq	.+36     	; 0x69e <__vector_13+0x7c>
 67a:	84 30       	cpi	r24, 0x04	; 4
 67c:	e9 f0       	breq	.+58     	; 0x6b8 <__vector_13+0x96>
 67e:	34 c0       	rjmp	.+104    	; 0x6e8 <__vector_13+0xc6>
	   {
			case RESET:
				uart_puts("RESET");
 680:	80 e6       	ldi	r24, 0x60	; 96
 682:	91 e0       	ldi	r25, 0x01	; 1
 684:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
				break;
 688:	33 c0       	rjmp	.+102    	; 0x6f0 <__vector_13+0xce>
			case GET_CODE:
				uart_puts("GET_CODE");
 68a:	86 e6       	ldi	r24, 0x66	; 102
 68c:	91 e0       	ldi	r25, 0x01	; 1
 68e:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
				break;
 692:	2e c0       	rjmp	.+92     	; 0x6f0 <__vector_13+0xce>
			case CHECK_CODE:
				uart_puts("CHECK_CODE");
 694:	8f e6       	ldi	r24, 0x6F	; 111
 696:	91 e0       	ldi	r25, 0x01	; 1
 698:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
				break;
 69c:	29 c0       	rjmp	.+82     	; 0x6f0 <__vector_13+0xce>
			case DOOR_OPEN:
				wrong_tries = 0;
 69e:	10 92 b3 01 	sts	0x01B3, r1	; 0x8001b3 <wrong_tries>
 6a2:	10 92 b4 01 	sts	0x01B4, r1	; 0x8001b4 <wrong_tries+0x1>
 6a6:	10 92 b5 01 	sts	0x01B5, r1	; 0x8001b5 <wrong_tries+0x2>
 6aa:	10 92 b6 01 	sts	0x01B6, r1	; 0x8001b6 <wrong_tries+0x3>
				uart_puts("DOOR_OPEN");
 6ae:	8a e7       	ldi	r24, 0x7A	; 122
 6b0:	91 e0       	ldi	r25, 0x01	; 1
 6b2:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
				break;
 6b6:	1c c0       	rjmp	.+56     	; 0x6f0 <__vector_13+0xce>
			case WRONG_CODE:
				wrong_tries++;
 6b8:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <wrong_tries>
 6bc:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <wrong_tries+0x1>
 6c0:	a0 91 b5 01 	lds	r26, 0x01B5	; 0x8001b5 <wrong_tries+0x2>
 6c4:	b0 91 b6 01 	lds	r27, 0x01B6	; 0x8001b6 <wrong_tries+0x3>
 6c8:	01 96       	adiw	r24, 0x01	; 1
 6ca:	a1 1d       	adc	r26, r1
 6cc:	b1 1d       	adc	r27, r1
 6ce:	80 93 b3 01 	sts	0x01B3, r24	; 0x8001b3 <wrong_tries>
 6d2:	90 93 b4 01 	sts	0x01B4, r25	; 0x8001b4 <wrong_tries+0x1>
 6d6:	a0 93 b5 01 	sts	0x01B5, r26	; 0x8001b5 <wrong_tries+0x2>
 6da:	b0 93 b6 01 	sts	0x01B6, r27	; 0x8001b6 <wrong_tries+0x3>
				uart_puts("WRONG_CODE");
 6de:	84 e8       	ldi	r24, 0x84	; 132
 6e0:	91 e0       	ldi	r25, 0x01	; 1
 6e2:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
				break;
 6e6:	04 c0       	rjmp	.+8      	; 0x6f0 <__vector_13+0xce>
			default:
				uart_puts("ERROR");
 6e8:	8f e8       	ldi	r24, 0x8F	; 143
 6ea:	91 e0       	ldi	r25, 0x01	; 1
 6ec:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
	   }
	   uart_puts("\n");
 6f0:	85 e9       	ldi	r24, 0x95	; 149
 6f2:	91 e0       	ldi	r25, 0x01	; 1
 6f4:	0e 94 c6 04 	call	0x98c	; 0x98c <uart_puts>
   }
   
   prev_state = current_state;
 6f8:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <current_state>
 6fc:	80 93 b2 01 	sts	0x01B2, r24	; 0x8001b2 <__data_end>
}
 700:	ff 91       	pop	r31
 702:	ef 91       	pop	r30
 704:	bf 91       	pop	r27
 706:	af 91       	pop	r26
 708:	9f 91       	pop	r25
 70a:	8f 91       	pop	r24
 70c:	7f 91       	pop	r23
 70e:	6f 91       	pop	r22
 710:	5f 91       	pop	r21
 712:	4f 91       	pop	r20
 714:	3f 91       	pop	r19
 716:	2f 91       	pop	r18
 718:	0f 90       	pop	r0
 71a:	0f be       	out	0x3f, r0	; 63
 71c:	0f 90       	pop	r0
 71e:	1f 90       	pop	r1
 720:	18 95       	reti

00000722 <__vector_9>:
/**
* @brief Timer used for resetting after certain time
* @par Has 2 functions - when the code is being put in, limits the time for that to 20s, when the code is entered, waits for 5s before resetting the machine.
*/
ISR(TIMER2_OVF_vect)
{
 722:	1f 92       	push	r1
 724:	0f 92       	push	r0
 726:	0f b6       	in	r0, 0x3f	; 63
 728:	0f 92       	push	r0
 72a:	11 24       	eor	r1, r1
 72c:	2f 93       	push	r18
 72e:	3f 93       	push	r19
 730:	4f 93       	push	r20
 732:	5f 93       	push	r21
 734:	6f 93       	push	r22
 736:	7f 93       	push	r23
 738:	8f 93       	push	r24
 73a:	9f 93       	push	r25
 73c:	af 93       	push	r26
 73e:	bf 93       	push	r27
 740:	ef 93       	push	r30
 742:	ff 93       	push	r31
 744:	cf 93       	push	r28
 746:	df 93       	push	r29
 748:	00 d0       	rcall	.+0      	; 0x74a <__vector_9+0x28>
 74a:	1f 92       	push	r1
 74c:	cd b7       	in	r28, 0x3d	; 61
 74e:	de b7       	in	r29, 0x3e	; 62
	char str[] = "  ";
 750:	80 e2       	ldi	r24, 0x20	; 32
 752:	90 e2       	ldi	r25, 0x20	; 32
 754:	9a 83       	std	Y+2, r25	; 0x02
 756:	89 83       	std	Y+1, r24	; 0x01
 758:	1b 82       	std	Y+3, r1	; 0x03
	if(current_state == DOOR_OPEN)
 75a:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <current_state>
 75e:	83 30       	cpi	r24, 0x03	; 3
 760:	09 f4       	brne	.+2      	; 0x764 <__vector_9+0x42>
		PORTB|=(0x08);
 762:	2b 9a       	sbi	0x05, 3	; 5
	if(current_state == WRONG_CODE && counter2 == 250)
 764:	80 91 bb 01 	lds	r24, 0x01BB	; 0x8001bb <current_state>
 768:	84 30       	cpi	r24, 0x04	; 4
 76a:	09 f0       	breq	.+2      	; 0x76e <__vector_9+0x4c>
 76c:	4a c0       	rjmp	.+148    	; 0x802 <__vector_9+0xe0>
 76e:	80 91 b7 01 	lds	r24, 0x01B7	; 0x8001b7 <counter2>
 772:	90 91 b8 01 	lds	r25, 0x01B8	; 0x8001b8 <counter2+0x1>
 776:	a0 91 b9 01 	lds	r26, 0x01B9	; 0x8001b9 <counter2+0x2>
 77a:	b0 91 ba 01 	lds	r27, 0x01BA	; 0x8001ba <counter2+0x3>
 77e:	8a 3f       	cpi	r24, 0xFA	; 250
 780:	91 05       	cpc	r25, r1
 782:	a1 05       	cpc	r26, r1
 784:	b1 05       	cpc	r27, r1
 786:	e9 f5       	brne	.+122    	; 0x802 <__vector_9+0xe0>
	{
		lcd_gotoxy(1, 0);
 788:	60 e0       	ldi	r22, 0x00	; 0
 78a:	81 e0       	ldi	r24, 0x01	; 1
 78c:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
		lcd_puts("ACCESS DENIED");
 790:	87 e9       	ldi	r24, 0x97	; 151
 792:	91 e0       	ldi	r25, 0x01	; 1
 794:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
		lcd_gotoxy(1, 1);
 798:	61 e0       	ldi	r22, 0x01	; 1
 79a:	81 e0       	ldi	r24, 0x01	; 1
 79c:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
		lcd_puts("WRONG TRIES:");
 7a0:	85 ea       	ldi	r24, 0xA5	; 165
 7a2:	91 e0       	ldi	r25, 0x01	; 1
 7a4:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
		lcd_gotoxy(13, 1);
 7a8:	61 e0       	ldi	r22, 0x01	; 1
 7aa:	8d e0       	ldi	r24, 0x0D	; 13
 7ac:	0e 94 a0 00 	call	0x140	; 0x140 <lcd_gotoxy>
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 7b0:	4a e0       	ldi	r20, 0x0A	; 10
 7b2:	be 01       	movw	r22, r28
 7b4:	6f 5f       	subi	r22, 0xFF	; 255
 7b6:	7f 4f       	sbci	r23, 0xFF	; 255
 7b8:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <wrong_tries>
 7bc:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <wrong_tries+0x1>
 7c0:	0e 94 d5 04 	call	0x9aa	; 0x9aa <__itoa_ncheck>
		itoa(wrong_tries, str, 10);
		lcd_puts(str);
 7c4:	ce 01       	movw	r24, r28
 7c6:	01 96       	adiw	r24, 0x01	; 1
 7c8:	0e 94 b2 00 	call	0x164	; 0x164 <lcd_puts>
		if(wrong_tries == 100)
 7cc:	80 91 b3 01 	lds	r24, 0x01B3	; 0x8001b3 <wrong_tries>
 7d0:	90 91 b4 01 	lds	r25, 0x01B4	; 0x8001b4 <wrong_tries+0x1>
 7d4:	a0 91 b5 01 	lds	r26, 0x01B5	; 0x8001b5 <wrong_tries+0x2>
 7d8:	b0 91 b6 01 	lds	r27, 0x01B6	; 0x8001b6 <wrong_tries+0x3>
 7dc:	84 36       	cpi	r24, 0x64	; 100
 7de:	91 05       	cpc	r25, r1
 7e0:	a1 05       	cpc	r26, r1
 7e2:	b1 05       	cpc	r27, r1
 7e4:	49 f4       	brne	.+18     	; 0x7f8 <__vector_9+0xd6>
			wrong_tries = 0;
 7e6:	10 92 b3 01 	sts	0x01B3, r1	; 0x8001b3 <wrong_tries>
 7ea:	10 92 b4 01 	sts	0x01B4, r1	; 0x8001b4 <wrong_tries+0x1>
 7ee:	10 92 b5 01 	sts	0x01B5, r1	; 0x8001b5 <wrong_tries+0x2>
 7f2:	10 92 b6 01 	sts	0x01B6, r1	; 0x8001b6 <wrong_tries+0x3>
 7f6:	05 c0       	rjmp	.+10     	; 0x802 <__vector_9+0xe0>
		if(wrong_tries > 4)
 7f8:	05 97       	sbiw	r24, 0x05	; 5
 7fa:	a1 05       	cpc	r26, r1
 7fc:	b1 05       	cpc	r27, r1
 7fe:	08 f0       	brcs	.+2      	; 0x802 <__vector_9+0xe0>
			PORTB|=(0x04);
 800:	2a 9a       	sbi	0x05, 2	; 5
	}
	
	counter2++;
 802:	80 91 b7 01 	lds	r24, 0x01B7	; 0x8001b7 <counter2>
 806:	90 91 b8 01 	lds	r25, 0x01B8	; 0x8001b8 <counter2+0x1>
 80a:	a0 91 b9 01 	lds	r26, 0x01B9	; 0x8001b9 <counter2+0x2>
 80e:	b0 91 ba 01 	lds	r27, 0x01BA	; 0x8001ba <counter2+0x3>
 812:	01 96       	adiw	r24, 0x01	; 1
 814:	a1 1d       	adc	r26, r1
 816:	b1 1d       	adc	r27, r1
 818:	80 93 b7 01 	sts	0x01B7, r24	; 0x8001b7 <counter2>
 81c:	90 93 b8 01 	sts	0x01B8, r25	; 0x8001b8 <counter2+0x1>
 820:	a0 93 b9 01 	sts	0x01B9, r26	; 0x8001b9 <counter2+0x2>
 824:	b0 93 ba 01 	sts	0x01BA, r27	; 0x8001ba <counter2+0x3>
	if(counter2 == 1250)//timer set 4ms or 16 ms, 1250*4ms = 5s, 1250*16ms = 20s
 828:	82 3e       	cpi	r24, 0xE2	; 226
 82a:	94 40       	sbci	r25, 0x04	; 4
 82c:	a1 05       	cpc	r26, r1
 82e:	b1 05       	cpc	r27, r1
 830:	89 f4       	brne	.+34     	; 0x854 <__vector_9+0x132>
	{
		PORTB&=~(0x08);
 832:	2b 98       	cbi	0x05, 3	; 5
		PORTB&=~(0x04);
 834:	2a 98       	cbi	0x05, 2	; 5
		counter2 = 0;
 836:	10 92 b7 01 	sts	0x01B7, r1	; 0x8001b7 <counter2>
 83a:	10 92 b8 01 	sts	0x01B8, r1	; 0x8001b8 <counter2+0x1>
 83e:	10 92 b9 01 	sts	0x01B9, r1	; 0x8001b9 <counter2+0x2>
 842:	10 92 ba 01 	sts	0x01BA, r1	; 0x8001ba <counter2+0x3>
		current_state = RESET;
 846:	10 92 bb 01 	sts	0x01BB, r1	; 0x8001bb <current_state>
		TIM2_overflow_interrupt_disable();
 84a:	e0 e7       	ldi	r30, 0x70	; 112
 84c:	f0 e0       	ldi	r31, 0x00	; 0
 84e:	80 81       	ld	r24, Z
 850:	8e 7f       	andi	r24, 0xFE	; 254
 852:	80 83       	st	Z, r24
	}
 854:	0f 90       	pop	r0
 856:	0f 90       	pop	r0
 858:	0f 90       	pop	r0
 85a:	df 91       	pop	r29
 85c:	cf 91       	pop	r28
 85e:	ff 91       	pop	r31
 860:	ef 91       	pop	r30
 862:	bf 91       	pop	r27
 864:	af 91       	pop	r26
 866:	9f 91       	pop	r25
 868:	8f 91       	pop	r24
 86a:	7f 91       	pop	r23
 86c:	6f 91       	pop	r22
 86e:	5f 91       	pop	r21
 870:	4f 91       	pop	r20
 872:	3f 91       	pop	r19
 874:	2f 91       	pop	r18
 876:	0f 90       	pop	r0
 878:	0f be       	out	0x3f, r0	; 63
 87a:	0f 90       	pop	r0
 87c:	1f 90       	pop	r1
 87e:	18 95       	reti

00000880 <__vector_18>:
    /* store buffer index */
    UART_RxTail = tmptail;

    UART_LastRxError = 0;
    return (lastRxError << 8) + data;
}/* uart_getc */
 880:	1f 92       	push	r1
 882:	0f 92       	push	r0
 884:	0f b6       	in	r0, 0x3f	; 63
 886:	0f 92       	push	r0
 888:	11 24       	eor	r1, r1
 88a:	2f 93       	push	r18
 88c:	8f 93       	push	r24
 88e:	9f 93       	push	r25
 890:	ef 93       	push	r30
 892:	ff 93       	push	r31
 894:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 898:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 89c:	8c 71       	andi	r24, 0x1C	; 28
 89e:	e0 91 be 01 	lds	r30, 0x01BE	; 0x8001be <UART_RxHead>
 8a2:	ef 5f       	subi	r30, 0xFF	; 255
 8a4:	ef 71       	andi	r30, 0x1F	; 31
 8a6:	90 91 bd 01 	lds	r25, 0x01BD	; 0x8001bd <UART_RxTail>
 8aa:	e9 17       	cp	r30, r25
 8ac:	39 f0       	breq	.+14     	; 0x8bc <__vector_18+0x3c>
 8ae:	e0 93 be 01 	sts	0x01BE, r30	; 0x8001be <UART_RxHead>
 8b2:	f0 e0       	ldi	r31, 0x00	; 0
 8b4:	ef 53       	subi	r30, 0x3F	; 63
 8b6:	fe 4f       	sbci	r31, 0xFE	; 254
 8b8:	20 83       	st	Z, r18
 8ba:	01 c0       	rjmp	.+2      	; 0x8be <__vector_18+0x3e>
 8bc:	82 e0       	ldi	r24, 0x02	; 2
 8be:	90 91 bc 01 	lds	r25, 0x01BC	; 0x8001bc <UART_LastRxError>
 8c2:	89 2b       	or	r24, r25
 8c4:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <UART_LastRxError>
 8c8:	ff 91       	pop	r31
 8ca:	ef 91       	pop	r30
 8cc:	9f 91       	pop	r25
 8ce:	8f 91       	pop	r24
 8d0:	2f 91       	pop	r18
 8d2:	0f 90       	pop	r0
 8d4:	0f be       	out	0x3f, r0	; 63
 8d6:	0f 90       	pop	r0
 8d8:	1f 90       	pop	r1
 8da:	18 95       	reti

000008dc <__vector_19>:
 8dc:	1f 92       	push	r1
 8de:	0f 92       	push	r0
 8e0:	0f b6       	in	r0, 0x3f	; 63
 8e2:	0f 92       	push	r0
 8e4:	11 24       	eor	r1, r1
 8e6:	8f 93       	push	r24
 8e8:	9f 93       	push	r25
 8ea:	ef 93       	push	r30
 8ec:	ff 93       	push	r31
 8ee:	90 91 c0 01 	lds	r25, 0x01C0	; 0x8001c0 <UART_TxHead>
 8f2:	80 91 bf 01 	lds	r24, 0x01BF	; 0x8001bf <UART_TxTail>
 8f6:	98 17       	cp	r25, r24
 8f8:	69 f0       	breq	.+26     	; 0x914 <__stack+0x15>
 8fa:	e0 91 bf 01 	lds	r30, 0x01BF	; 0x8001bf <UART_TxTail>
 8fe:	ef 5f       	subi	r30, 0xFF	; 255
 900:	ef 71       	andi	r30, 0x1F	; 31
 902:	e0 93 bf 01 	sts	0x01BF, r30	; 0x8001bf <UART_TxTail>
 906:	f0 e0       	ldi	r31, 0x00	; 0
 908:	ef 51       	subi	r30, 0x1F	; 31
 90a:	fe 4f       	sbci	r31, 0xFE	; 254
 90c:	80 81       	ld	r24, Z
 90e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
 912:	05 c0       	rjmp	.+10     	; 0x91e <__stack+0x1f>
 914:	e1 ec       	ldi	r30, 0xC1	; 193
 916:	f0 e0       	ldi	r31, 0x00	; 0
 918:	80 81       	ld	r24, Z
 91a:	8f 7d       	andi	r24, 0xDF	; 223
 91c:	80 83       	st	Z, r24
 91e:	ff 91       	pop	r31
 920:	ef 91       	pop	r30
 922:	9f 91       	pop	r25
 924:	8f 91       	pop	r24
 926:	0f 90       	pop	r0
 928:	0f be       	out	0x3f, r0	; 63
 92a:	0f 90       	pop	r0
 92c:	1f 90       	pop	r1
 92e:	18 95       	reti

00000930 <uart_init>:
 930:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <UART_TxHead>
 934:	10 92 bf 01 	sts	0x01BF, r1	; 0x8001bf <UART_TxTail>
 938:	10 92 be 01 	sts	0x01BE, r1	; 0x8001be <UART_RxHead>
 93c:	10 92 bd 01 	sts	0x01BD, r1	; 0x8001bd <UART_RxTail>
 940:	99 23       	and	r25, r25
 942:	1c f4       	brge	.+6      	; 0x94a <uart_init+0x1a>
 944:	22 e0       	ldi	r18, 0x02	; 2
 946:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
 94a:	90 78       	andi	r25, 0x80	; 128
 94c:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
 950:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
 954:	88 e9       	ldi	r24, 0x98	; 152
 956:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
 95a:	86 e0       	ldi	r24, 0x06	; 6
 95c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
 960:	08 95       	ret

00000962 <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;


    tmphead = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 962:	20 91 c0 01 	lds	r18, 0x01C0	; 0x8001c0 <UART_TxHead>
 966:	2f 5f       	subi	r18, 0xFF	; 255
 968:	2f 71       	andi	r18, 0x1F	; 31

    while (tmphead == UART_TxTail)
 96a:	90 91 bf 01 	lds	r25, 0x01BF	; 0x8001bf <UART_TxTail>
 96e:	29 17       	cp	r18, r25
 970:	e1 f3       	breq	.-8      	; 0x96a <uart_putc+0x8>
    {
        ;/* wait for free space in buffer */
    }

    UART_TxBuf[tmphead] = data;
 972:	e2 2f       	mov	r30, r18
 974:	f0 e0       	ldi	r31, 0x00	; 0
 976:	ef 51       	subi	r30, 0x1F	; 31
 978:	fe 4f       	sbci	r31, 0xFE	; 254
 97a:	80 83       	st	Z, r24
    UART_TxHead         = tmphead;
 97c:	20 93 c0 01 	sts	0x01C0, r18	; 0x8001c0 <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL |= _BV(UART0_UDRIE);
 980:	e1 ec       	ldi	r30, 0xC1	; 193
 982:	f0 e0       	ldi	r31, 0x00	; 0
 984:	80 81       	ld	r24, Z
 986:	80 62       	ori	r24, 0x20	; 32
 988:	80 83       	st	Z, r24
 98a:	08 95       	ret

0000098c <uart_puts>:
 * Purpose:  transmit string to UART
 * Input:    string to be transmitted
 * Returns:  none
 **************************************************************************/
void uart_puts(const char *s)
{
 98c:	cf 93       	push	r28
 98e:	df 93       	push	r29
 990:	ec 01       	movw	r28, r24
    while (*s)
 992:	88 81       	ld	r24, Y
 994:	88 23       	and	r24, r24
 996:	31 f0       	breq	.+12     	; 0x9a4 <uart_puts+0x18>
 998:	21 96       	adiw	r28, 0x01	; 1
        uart_putc(*s++);
 99a:	0e 94 b1 04 	call	0x962	; 0x962 <uart_putc>
 * Input:    string to be transmitted
 * Returns:  none
 **************************************************************************/
void uart_puts(const char *s)
{
    while (*s)
 99e:	89 91       	ld	r24, Y+
 9a0:	81 11       	cpse	r24, r1
 9a2:	fb cf       	rjmp	.-10     	; 0x99a <uart_puts+0xe>
        uart_putc(*s++);
}/* uart_puts */
 9a4:	df 91       	pop	r29
 9a6:	cf 91       	pop	r28
 9a8:	08 95       	ret

000009aa <__itoa_ncheck>:
 9aa:	bb 27       	eor	r27, r27
 9ac:	4a 30       	cpi	r20, 0x0A	; 10
 9ae:	31 f4       	brne	.+12     	; 0x9bc <__itoa_ncheck+0x12>
 9b0:	99 23       	and	r25, r25
 9b2:	22 f4       	brpl	.+8      	; 0x9bc <__itoa_ncheck+0x12>
 9b4:	bd e2       	ldi	r27, 0x2D	; 45
 9b6:	90 95       	com	r25
 9b8:	81 95       	neg	r24
 9ba:	9f 4f       	sbci	r25, 0xFF	; 255
 9bc:	0c 94 e1 04 	jmp	0x9c2	; 0x9c2 <__utoa_common>

000009c0 <__utoa_ncheck>:
 9c0:	bb 27       	eor	r27, r27

000009c2 <__utoa_common>:
 9c2:	fb 01       	movw	r30, r22
 9c4:	55 27       	eor	r21, r21
 9c6:	aa 27       	eor	r26, r26
 9c8:	88 0f       	add	r24, r24
 9ca:	99 1f       	adc	r25, r25
 9cc:	aa 1f       	adc	r26, r26
 9ce:	a4 17       	cp	r26, r20
 9d0:	10 f0       	brcs	.+4      	; 0x9d6 <__utoa_common+0x14>
 9d2:	a4 1b       	sub	r26, r20
 9d4:	83 95       	inc	r24
 9d6:	50 51       	subi	r21, 0x10	; 16
 9d8:	b9 f7       	brne	.-18     	; 0x9c8 <__utoa_common+0x6>
 9da:	a0 5d       	subi	r26, 0xD0	; 208
 9dc:	aa 33       	cpi	r26, 0x3A	; 58
 9de:	08 f0       	brcs	.+2      	; 0x9e2 <__utoa_common+0x20>
 9e0:	a9 5d       	subi	r26, 0xD9	; 217
 9e2:	a1 93       	st	Z+, r26
 9e4:	00 97       	sbiw	r24, 0x00	; 0
 9e6:	79 f7       	brne	.-34     	; 0x9c6 <__utoa_common+0x4>
 9e8:	b1 11       	cpse	r27, r1
 9ea:	b1 93       	st	Z+, r27
 9ec:	11 92       	st	Z+, r1
 9ee:	cb 01       	movw	r24, r22
 9f0:	0c 94 fa 04 	jmp	0x9f4	; 0x9f4 <strrev>

000009f4 <strrev>:
 9f4:	dc 01       	movw	r26, r24
 9f6:	fc 01       	movw	r30, r24
 9f8:	67 2f       	mov	r22, r23
 9fa:	71 91       	ld	r23, Z+
 9fc:	77 23       	and	r23, r23
 9fe:	e1 f7       	brne	.-8      	; 0x9f8 <strrev+0x4>
 a00:	32 97       	sbiw	r30, 0x02	; 2
 a02:	04 c0       	rjmp	.+8      	; 0xa0c <strrev+0x18>
 a04:	7c 91       	ld	r23, X
 a06:	6d 93       	st	X+, r22
 a08:	70 83       	st	Z, r23
 a0a:	62 91       	ld	r22, -Z
 a0c:	ae 17       	cp	r26, r30
 a0e:	bf 07       	cpc	r27, r31
 a10:	c8 f3       	brcs	.-14     	; 0xa04 <strrev+0x10>
 a12:	08 95       	ret

00000a14 <_exit>:
 a14:	f8 94       	cli

00000a16 <__stop_program>:
 a16:	ff cf       	rjmp	.-2      	; 0xa16 <__stop_program>
